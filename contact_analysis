##Per frame contact analysis of substrate (eg. ATP) with the protein.

#1. This analysis was done using the below scripts prepared by Priti Roy

#Library Import
import numpy as np
import MDAnalysis as mda
from collections import Counter, OrderedDict

#System upload
u = mda.Universe("stripped.atp_r1.prmtop", "all_atp_combine.dcd");
sel = u.select_atoms("protein and around 5.0 (resid 600:607 and name P)", updating=True);
f = []

#Analyze over the trajectory
for ts in u.trajectory:
	data = sel.resids
	uniq_ids = str(np.unique(data))
	f.append(uniq_ids)
np.savetxt('r1p1_ATP_prot_res_50ns.out', f, '%s', delimiter=',', newline='\n')

#Formating the elements of lists
f2 = []
for i in f:
	elm = i.split()
	elm.pop(0)
	elm2 = [s.replace(']', '') for s in elm]
	f2.append(elm2)

#Unique elements with occurance number
c = Counter(e for l in f2 for e in l)
unq_id = list(c)
data = []
for p in unq_id:
	data.append('%s  %d' % (p, c[p]))
print(data)
y = np.array(data)
np.savetxt('r1p1_ATP_prot_count.out', y, '%s')

##The output (i. e. r1p1_ATP_prot_count.out) was further processed to obtain the %contact per residue based on the total trajectories.

import numpy as np
data = np.loadtxt("r1p1_ATP_prot_count.out")
x = data[:,0]
y = data[:,1]
data_new = np.transpose([x+0, (y/1095000)*100])
np.savetxt('r1p1_ATP_prot.out', data_new, '%s')


##The above contact enable us to know the exact residues interacting within ≤ 5.0 Å to any substrate atom or P of RNA.
##Since our simulation is boosted, reweighing the energy is critical for more accurate analysis.
##So, we recalculated the contact using distance within ≤ 5.0 Å of motifs Ia, IV, and V to any RNA phosphorus and estimated %unweighted integrand and %reweighed distance. 

#2. Here, I use cpptraj module (AMBER) to obtain all interatomic distances within 5 Angstrom of residue-ligand interaction.

#to delete column 1
f = open("atp_rna_310.dat", "r") #distances from cpptraj with frame index on first column
g = open("atp_rna-310.dat", "w")

for line in f:
    if line.strip():
        g.write("\t".join(line.split()[1:]) + "\n")

f.close()
g.close()

##Assuming there are 1000 frames (rows) and 25 possible interactions (columns) and you desire to keep only the first element <=5 on a row, if no value <=5 in the row, write 0

table = np.loadtxt("atp_rna-310.dat") #distances
new_table = []

for row in table:
    for value in row:
        if value <= 5:
            new_table.append(value)
            break
    else:
        new_table.append(0)

print(new_table)
z = np.transpose(new_table)
np.savetxt('atprna_310.dat', z, '%s')

##The %contact per frames with any interatomic distance (≤ 5.0 Å) residue-substrate is equal to the first analysis.

#3. Do normalized probability density and integrate distances 0-5 

#import libraries
from scipy.integrate import quad
from scipy.stats import norm
from scipy.stats import sem
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats

unweighted PDF
x = np.loadtxt("atprna_310.dat")
x_min = np.min(x)
x_max = np.max(x)
mean = np.mean(x) 
std = np.std(x)

def normal_distribution_function(x):
    value = scipy.stats.norm.pdf(x,mean,std)
    return value

x1 = 0
x2 = 5
res, err = quad(normal_distribution_function, x1, x2)
print('Normal Distribution (mean,std):',mean,std)
print('Integration bewteen {} and {} --> '.format(x1,x2),res)


#4. Reweigh distance atprna_310.dat using PyReweighting-1D.py from http://miaolab.org/PyReweighting/ 
Convert the Cumulant expansion to the 2nd order ("Gaussian approximation") output (pmf-c2*) to normalized pobability density using pmf_data = np.exp(-y/0.6) (Normalized probability density = e^(-free energy/RT)).

Example
import scipy.integrate as integrate

data = np.loadtxt("pmf-c2-atprna_310.dat.xvg")
x = data[:,1]

def prob_density(x):
    return np.exp(-x/0.6)

x1 = 0
x2 = 5

integrand = integrate.quad(prob_density,x1,x2)

print("The integrand of points x1 and x2 is",integrand[0])
